import { ensureDir, copy, exists } from "https://deno.land/std/fs/mod.ts";
import { join } from "https://deno.land/std/path/mod.ts";

async function downloadInstallScript(repoUrl: string): Promise<void> {
  const tempDir = await Deno.makeTempDir();
  
  try {
    console.log("üì• Ba1ixando script de instala√ß√£o...");
    const cloneProcess = new Deno.Command("git", {
      args: ["clone", "--depth", "1", repoUrl, tempDir],
    });

    const cloneOutput = await cloneProcess.output();
    if (!cloneOutput.success) {
      const decoder = new TextDecoder();
      throw new Error(`Falha ao clonar o reposit√≥rio:\n${decoder.decode(cloneOutput.stderr)}`);
    }

    const sourceFile = join(tempDir, "install-component.ts");
    const targetFile = "install-component.ts";

    await copy(sourceFile, targetFile, { overwrite: true });
    console.log("‚úÖ Script de instala√ß√£o baixado com sucesso!");
  } finally {
    await Deno.remove(tempDir, { recursive: true });
  }
}

// Fun√ß√£o para listar os arquivos .tsx do reposit√≥rio remoto
async function listComponentsRemote(repoUrl: string): Promise<string[]> {
  const tempDir = await Deno.makeTempDir();

  console.log("üîç Clonando reposit√≥rio remoto...");
  const cloneProcess = new Deno.Command("git", {
    args: ["clone", "--depth", "1", "--filter=blob:none", "--sparse", repoUrl, tempDir],
  });

  const cloneOutput = await cloneProcess.output();
  if (!cloneOutput.success) {
    const decoder = new TextDecoder();
    throw new Error(`Falha ao clonar o reposit√≥rio remoto:\n${decoder.decode(cloneOutput.stderr)}`);
  }

  console.log("üîç Buscando componentes correspondentes...");
  const listProcess = new Deno.Command("git", {
    args: ["ls-tree", "--full-tree", "-r", "HEAD", "components"],
    cwd: tempDir,
  });

  const listOutput = await listProcess.output();
  if (!listOutput.success) {
    const decoder = new TextDecoder();
    throw new Error(`Falha ao listar os componentes:\n${decoder.decode(listOutput.stderr)}`);
  }

  const decoder = new TextDecoder();
  const output = decoder.decode(listOutput.stdout);

  const components = output
    .split("\n")
    .filter(line => line.endsWith(".tsx"))
    .map(line => line.split("\t")[1]);

  await Deno.remove(tempDir, { recursive: true });

  return components;
}

async function installComponent(componentName: string, repoUrl: string) {
  let tempDir: string | undefined;

  try {
    console.log("üîç Verificando ambiente...");
    const currentDir = Deno.cwd();
    const componentsDir = join(currentDir, "src", "components");
    const componentDir = join(componentsDir, componentName);

    console.log("üìÅ Verificando estrutura de pastas...");
    await ensureDir(componentDir);

    console.log("üì¶ Preparando para baixar o componente...");
    tempDir = await Deno.makeTempDir();

    console.log("üîç Clonando reposit√≥rio remoto...");
    const cloneProcess = new Deno.Command("git", {
      args: [
        "clone",
        "--depth", "1",
        "--filter=blob:none",
        "--sparse",
        repoUrl,
        tempDir,
      ],
    });

    const cloneOutput = await cloneProcess.output();
    if (!cloneOutput.success) {
      const decoder = new TextDecoder();
      throw new Error(`Falha ao clonar reposit√≥rio:\n${decoder.decode(cloneOutput.stderr)}`);
    }

    console.log("üîç Buscando componentes correspondentes...");
    const components = await listComponentsRemote(repoUrl);
    if (components.length === 0) {
      throw new Error("Nenhum componente encontrado no reposit√≥rio.");
    }

    if (components.length === 1) {
      console.log(`Apenas um componente encontrado: ${components[0]}`);
    } else {
      console.log("Escolha um componente para instalar:");
      components.forEach((component, index) => {
        console.log(`${index + 1}: ${component}`);
      });

      const selectedIndex = parseInt(Deno.args[0] ?? "", 10) - 1;
      if (isNaN(selectedIndex) || selectedIndex < 0 || selectedIndex >= components.length) {
        throw new Error("Sele√ß√£o inv√°lida. Por favor, escolha um n√∫mero de 1 a " + components.length);
      }

      console.log(`Voc√™ escolheu o componente: ${components[selectedIndex]}`);
    }

    const selectedComponent = components.length === 1 ? components[0] : components[parseInt(Deno.args[0] ?? "", 10) - 1];
    const componentDirPath = selectedComponent.replace(".tsx", "");

    console.log("üîç Localizando componente...");

    // Corre√ß√£o do sparse-checkout para incluir o diret√≥rio components
    const sparseProcess = new Deno.Command("git", {
      args: ["-C", tempDir, "sparse-checkout", "set", "components"],
    });

    const sparseOutput = await sparseProcess.output();
    if (!sparseOutput.success) {
      const decoder = new TextDecoder();
      throw new Error(`Erro ao configurar sparse-checkout:\n${decoder.decode(sparseOutput.stderr)}`);
    }

    // Atualizar o reposit√≥rio ap√≥s configurar sparse-checkout
    const pullProcess = new Deno.Command("git", {
      args: ["-C", tempDir, "pull", "origin", "main"],
    });
    await pullProcess.output();

    // Corrigir o caminho do arquivo fonte
    const sourceFile = join(tempDir, selectedComponent);
    const targetFile = join(componentDir, componentName);

    console.log("üìã Copiando arquivos...");
    await copy(sourceFile, targetFile, { overwrite: true });

    console.log(`‚úÖ Componente instalado com sucesso em:\n${componentDir}`);

  } catch (error) {
    console.error("\n‚ùå Erro durante a instala√ß√£o:");
    console.error("----------------------------");
    console.error(error.message);
    console.error("----------------------------");
    console.error("\nüí° Dicas:");
    console.error("1. Verifique se est√° no diret√≥rio correto do projeto");
    console.error("2. Certifique-se de que tem permiss√µes para criar pastas e arquivos");
    console.error("3. Verifique se tem acesso ao reposit√≥rio");
    throw new Error("Erro na execu√ß√£o do script");
  } finally {
    if (tempDir) {
      console.log("\nüßπ Limpando arquivos tempor√°rios...");
      try {
        await Deno.remove(tempDir, { recursive: true });
      } catch {
        console.warn("‚ö†Ô∏è  N√£o foi poss√≠vel limpar alguns arquivos tempor√°rios");
      }
    }
  }
}

// Adicionar handler para requisi√ß√µes HTTP
async function handler(req: Request): Promise<Response> {
  const url = new URL(req.url);
  const componentName = url.searchParams.get("component");

  if (!componentName) {
    return new Response("Nome do componente √© obrigat√≥rio", {
      status: 400,
      headers: { "Content-Type": "application/json" },
    });
  }

  try {
    const repoUrl = "https://github.com/deco-sites/components.git";
    const components = await listComponentsRemote(repoUrl);
    
    // Encontrar o componente solicitado
    const matchingComponent = components.find(comp => 
      comp.toLowerCase().includes(componentName.toLowerCase())
    );

    if (!matchingComponent) {
      return new Response(JSON.stringify({
        error: "Componente n√£o encontrado",
        availableComponents: components
      }), {
        status: 404,
        headers: { "Content-Type": "application/json" },
      });
    }

    // Retornar o conte√∫do do componente
    const tempDir = await Deno.makeTempDir();
    try {
      const cloneProcess = new Deno.Command("git", {
        args: [
          "clone",
          "--depth", "1",
          "--filter=blob:none",
          "--sparse",
          repoUrl,
          tempDir,
        ],
      });

      await cloneProcess.output();

      const sparseProcess = new Deno.Command("git", {
        args: ["-C", tempDir, "sparse-checkout", "set", "components"],
      });
      await sparseProcess.output();

      const pullProcess = new Deno.Command("git", {
        args: ["-C", tempDir, "pull", "origin", "main"],
      });
      await pullProcess.output();

      const componentContent = await Deno.readTextFile(
        join(tempDir, matchingComponent)
      );

      return new Response(JSON.stringify({
        component: matchingComponent,
        content: componentContent,
      }), {
        headers: {
          "Content-Type": "application/json",
          "Access-Control-Allow-Origin": "*",
        },
      });
    } finally {
      await Deno.remove(tempDir, { recursive: true });
    }
  } catch (error) {
    return new Response(JSON.stringify({
      error: error.message
    }), {
      status: 500,
      headers: { "Content-Type": "application/json" },
    });
  }
}

// Adicionar serve handler para Deno Deploy
Deno.serve(handler);
